====================
FILE: CollisionDetector.java

package com.jakub.bone.application;

import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.domain.plane.Plane;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.ThreadContext;

import static com.jakub.bone.utills.Constant.*;

@Log4j2
public class CollisionDetector extends Thread {
    private ControlTower controlTower;
    public CollisionDetector(ControlTower controlTower){
        this.controlTower = controlTower;
    }

    @Override
    public void run() {
        ThreadContext.put("type", "Server");
        while(true) {
            try {
                checkCollision();
                Thread.sleep(COLLISION_CHECK_INTERVAL);
            } catch (InterruptedException ex){
                log.error("Collision detection interrupted: {}", ex.getMessage());
                Thread.currentThread().interrupt();
            }
        }
    }

    public void checkCollision() {
            for (int i = 0; i < controlTower.getPlanes().size(); i++) {
                Plane plane1 = controlTower.getPlanes().get(i);
                for (int j = i + 1; j < controlTower.getPlanes().size(); j++) {
                    Plane plane2 = controlTower.getPlanes().get(j);
                    if (arePlanesToClose(plane1.getNavigator().getLocation(), plane2.getNavigator().getLocation())) {
                        handleCollision(plane1, plane2);
                    }
                }
            }
    }

    private void handleCollision(Plane plane1, Plane plane2){
        String[] collidedIDs = {plane1.getFlightNumber(), plane2.getFlightNumber()};
        controlTower.getDatabase().getCOLLISION_DAO().registerCollisionToDB(collidedIDs);
        plane1.setDestroyed(true);
        plane2.setDestroyed(true);
        log.info("Collision detected between Plane [{}] and Plane [{}]", plane1.getFlightNumber(), plane2.getFlightNumber());
    }

    /*
     * Checks if two planes are too close to each other
     *
     * Because the animation uses scaled aircraft models, the system has been adjusted to their size
     * Introduced a 500-meter offset, ensuring collisions visually occur when the models actually touch
     *
     * In practice, if the horizontal distance <= 500 and the altitude difference <= 10,
     * it is considered a potential collision risk
     */
    private boolean arePlanesToClose(Location loc1, Location loc2) {
        double horizontalDistance = Math.sqrt(
                Math.pow(loc1.getX() - loc2.getX(), 2) +
                        Math.pow(loc1.getY() - loc2.getY(), 2)
        );
        double altDiff = Math.abs(loc1.getAltitude() - loc2.getAltitude());
        return horizontalDistance <= HORIZONTAL_COLLISION_DISTANCE && altDiff <= ALTITUDE_COLLISION_DISTANCE;
    }
}

====================
FILE: ControlTower.java

package com.jakub.bone.application;

import com.jakub.bone.domain.airport.Runway;
import com.jakub.bone.database.AirportDatabase;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;
import com.jakub.bone.domain.plane.Plane;

import java.sql.SQLException;
import java.util.ArrayList;

import java.util.List;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Supplier;

import static com.jakub.bone.utills.Constant.*;

@Log4j2
@Getter
public class ControlTower {
    private List<Plane> planes;
    private Lock lock;
    private AirportDatabase database;

    public ControlTower(AirportDatabase database) throws SQLException {
        this.planes = new ArrayList<>();
        this.lock = new ReentrantLock();
        this.database = database;
    }

    public void registerPlane(Plane plane) {
        executeWithLock(() -> {
            planes.add(plane);
            database.getPLANE_DAO().registerPlaneInDB(plane);
        });
    }

    public boolean isSpaceFull() {
        return executeWithLock(() -> planes.size() >= MAX_CAPACITY);
    }

    public boolean isAtCollisionRiskZone(Plane plane) {
        return executeWithLock(() -> planes.stream()
                .anyMatch(otherPlane -> plane.getNavigator().getRiskZoneWaypoints()
                .contains(otherPlane.getNavigator().getLocation())));
    }

    public boolean isRunwayAvailable(Runway runway){
        return executeWithLock(runway::isAvailable);
    }

    public void assignRunway(Runway runway) {
        executeWithLock(() -> runway.setAvailable(false));
    }

    public void releaseRunway(Runway runway) {
        executeWithLock(() -> runway.setAvailable(true));
    }

    public void releaseRunwayIfPlaneAtFinalApproach(Plane plane, Runway runway){
        if(plane.getNavigator().getLocation().equals(runway.getCorridor().getFinalApproachPoint())){
            releaseRunway(runway);
        }
    }

    public void removePlaneFromSpace(Plane plane) {
        executeWithLock(() -> planes.remove(plane));
    }

    public boolean isPlaneApproachingHoldingAltitude(Plane plane) {
        return plane.getNavigator().getLocation().getAltitude() == HOLDING_ENTRY_ALTITUDE;
    }

    public boolean hasLandedOnRunway(Plane plane, Runway runway){
        boolean hasLanded = plane.getNavigator().getLocation().equals(runway.getLandingPoint());
        if (hasLanded) {
            database.getPLANE_DAO().registerLandingInDB(plane);
        }
        return hasLanded;
    }

    public Plane getPlaneByFlightNumber(String flightNumber){
        return executeWithLock(() -> planes.stream()
                .filter(plane -> flightNumber.equals(plane.getFlightNumber()))
                .findFirst()
                .orElse(null));
    }


    // Helper methods for locks management
    private <T> T executeWithLock(Supplier<T> action){
        lock.lock();
        try {
            return action.get();
        } finally {
            lock.unlock();
        }
    }

    private void executeWithLock(Runnable action){
        lock.lock();
        try {
            action.run();
        } finally {
            lock.unlock();
        }
    }
}

====================
FILE: FlightPhaseCoordinator.java

package com.jakub.bone.application;

import com.jakub.bone.domain.airport.Airport;
import com.jakub.bone.domain.airport.Runway;
import com.jakub.bone.domain.airport.Location;
import lombok.extern.log4j.Log4j2;
import com.jakub.bone.domain.plane.Plane;
import com.jakub.bone.utills.Messenger;

import java.io.IOException;
import java.io.ObjectOutputStream;

import static com.jakub.bone.application.PlaneHandler.AirportInstruction.*;
import static com.jakub.bone.domain.plane.Plane.FlightPhase.*;
import static com.jakub.bone.utills.Constant.ENTRY_POINT_CORRIDOR_1;
import static com.jakub.bone.utills.Constant.ENTRY_POINT_CORRIDOR_2;

@Log4j2
public class FlightPhaseCoordinator {
    private ControlTower controlTower;
    private Airport airport;
    private Messenger messenger;
    private Runway availableRunway;
    private boolean descentLogged;
    private boolean holdPatternLogged;

    public FlightPhaseCoordinator(ControlTower controlTower, Airport airport, Messenger messenger) {
        this.controlTower = controlTower;
        this.airport = airport;
        this.messenger = messenger;
        this.descentLogged = false;
        this.holdPatternLogged = false;
    }

    public void processFlightPhase(Plane plane, Location location, ObjectOutputStream out) throws IOException, ClassNotFoundException {
        plane.getNavigator().setLocation(location);
        switch (plane.getPhase()) {
            case DESCENDING -> handleDescent(plane, out);
            case HOLDING -> handleHolding(plane, out);
            case LANDING -> handleLanding(plane);
            default -> log.warn("Plane [{}]: unknown flight phase for {}", plane.getFlightNumber(), plane.getPhase());
        }
    }

    private void handleDescent(Plane plane, ObjectOutputStream out) throws IOException {
        if (controlTower.isPlaneApproachingHoldingAltitude(plane)) {
            enterHolding(plane, out);
        } else {
            applyDescending(plane, out);
        }
    }

    private void handleHolding(Plane plane, ObjectOutputStream out) throws IOException {
        Runway runway = getRunwayIfPlaneAtCorridor(plane);
        availableRunway = runway;

        if(runway != null && controlTower.isRunwayAvailable(runway)){
            applyLanding(plane, runway, out);
        } else {
            applyHolding(plane, out);
        }
    }

    private void handleLanding(Plane plane) throws IOException, ClassNotFoundException {
        if (controlTower.hasLandedOnRunway(plane, availableRunway)) {
            plane.setLanded(true);
            try{
                Thread.sleep(500);
            } catch (InterruptedException ex){
                ex.getMessage();
            }
            controlTower.removePlaneFromSpace(plane);
            log.info("Plane [{}]: successfully landed on runway [{}]", plane.getFlightNumber(), availableRunway.getId());
            return;
        }
        controlTower.releaseRunwayIfPlaneAtFinalApproach(plane, availableRunway);
    }
    private void enterHolding(Plane plane, ObjectOutputStream out) throws IOException {
        messenger.send(DESCENT, out);
        plane.setPhase(HOLDING);
        if (!holdPatternLogged) {
            log.info("Plane [{}] enter {}", plane.getFlightNumber(), HOLDING);
            holdPatternLogged = true;
        }
    }

    private void applyDescending(Plane plane, ObjectOutputStream out) throws IOException {
        messenger.send(DESCENT, out);
        plane.setPhase(DESCENDING);
        if (!descentLogged) {
            log.info("Plane [{}]: instructed to {}", plane.getFlightNumber(), DESCENT);
            descentLogged = true;
        }
    }

    private void applyHolding(Plane plane, ObjectOutputStream out) throws IOException {
        messenger.send(HOLD_PATTERN, out);
        plane.setPhase(HOLDING);
    }

    private void applyLanding(Plane plane, Runway runway, ObjectOutputStream out) throws IOException {
        controlTower.assignRunway(runway);
        plane.setPhase(LANDING);
        messenger.send(LAND, out);
        messenger.send(runway, out);
        log.info("Plane [{}]: instructed to {} on runway [{}]", plane.getFlightNumber(), LAND, runway.getId());
    }

    private Runway getRunwayIfPlaneAtCorridor(Plane plane) {
        Runway runway;
        if (plane.getNavigator().getLocation().equals(ENTRY_POINT_CORRIDOR_1)){
            return runway = Airport.runway1;
        }
        else if (plane.getNavigator().getLocation().equals(ENTRY_POINT_CORRIDOR_2)) {
            return runway = Airport.runway2;
        }
        return null;
    }
}

====================
FILE: PlaneHandler.java

package com.jakub.bone.application;

import com.jakub.bone.domain.airport.Airport;
import com.jakub.bone.utills.Messenger;
import com.jakub.bone.domain.airport.Location;
import lombok.extern.log4j.Log4j2;
import com.jakub.bone.domain.plane.Plane;
import org.apache.logging.log4j.ThreadContext;

import java.io.*;
import java.net.Socket;
import java.net.SocketException;

import static com.jakub.bone.application.PlaneHandler.AirportInstruction.*;
import static com.jakub.bone.domain.plane.Plane.FlightPhase.DESCENDING;

@Log4j2
public class PlaneHandler extends Thread {
    public enum AirportInstruction {
        DESCENT, HOLD_PATTERN, LAND, FULL, COLLISION, RISK_ZONE
    }

    private final Socket clientSocket;
    private final ControlTower controlTower;
    private final Airport airport;
    private Messenger messenger;
    private FlightPhaseCoordinator phaseCoordinator;

    public PlaneHandler(Socket clientSocket, ControlTower controlTower, Airport airport) {
        this.clientSocket = clientSocket;
        this.controlTower = controlTower;
        this.airport = airport;
        this.messenger = new Messenger();
        this.phaseCoordinator = new FlightPhaseCoordinator(controlTower, airport, messenger);
    }

    @Override
    public void run() {
        ThreadContext.put("type", "Server");
        try (ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream())) {

            handleClient(in, out);

        } catch (EOFException | SocketException ex) {
            log.warn("Connection to client lost. Client disconnected: {}", ex.getMessage());
        } catch (IOException | ClassNotFoundException ex) {
            log.error("Error occurred while handling client request: {}", ex.getMessage(), ex);
        } finally {
            try {
                clientSocket.close();
            } catch (IOException ex) {
                log.error("Failed to close client socket: {}", ex.getMessage(), ex);
            }
        }
    }

    private void handleClient(ObjectInputStream in, ObjectOutputStream out) throws IOException, ClassNotFoundException {
        Plane plane = messenger.receiveAndParse(in, Plane.class);

        if (!isPlaneRegistered(plane, out)) {
            return;
        }

        managePlane(plane, in, out);
    }

    private boolean isPlaneRegistered(Plane plane, ObjectOutputStream out) throws IOException {
        if (controlTower.isSpaceFull()) {
            messenger.send(FULL, out);
            log.info("Plane [{}]: no capacity in airspace", plane.getFlightNumber());
            return false;
        }

        try{
            Thread.sleep(1000);
        } catch (InterruptedException ex){
            ex.getMessage();
        }

        if (controlTower.isAtCollisionRiskZone(plane)) {
            messenger.send(RISK_ZONE, out);
            log.info("Plane [{}]: initial location occupied. Redirecting", plane.getFlightNumber());
            return false;
        }
        controlTower.registerPlane(plane);

        log.info("Plane [{}]: registered at ({}, {}, {}) ", plane.getFlightNumber(), plane.getNavigator().getLocation().getX(), plane.getNavigator().getLocation().getY(), plane.getNavigator().getLocation().getAltitude());
        return true;
    }

    private void managePlane(Plane plane, ObjectInputStream in, ObjectOutputStream out) throws IOException, ClassNotFoundException {
        plane.setPhase(DESCENDING);

        while (true) {
            double fuelLevel = messenger.receiveAndParse(in, Double.class);
            plane.getFuelManager().setFuelLevel(fuelLevel);

            if (fuelLevel <= 0) {
                handleOutOfFuel(plane);
                return;
            }

            Location location = messenger.receiveAndParse(in, Location.class);
            phaseCoordinator.processFlightPhase(plane, location, out);

            if (plane.isDestroyed()) {
                handleCollision(plane, out);
                return;
            }

            if (plane.isLanded()) {
                log.info("Plane [{}]: successfully landed", plane.getFlightNumber());
                return;
            }
        }
    }

    private void handleCollision(Plane plane, ObjectOutputStream out) throws IOException {
        if(plane.getAssignedRunway() != null){
            controlTower.releaseRunway(plane.getAssignedRunway());
        }
        controlTower.getPlanes().remove(plane);
        messenger.send(COLLISION, out);

        try{
            Thread.sleep(2000);
        } catch (InterruptedException ex){
            ex.printStackTrace();
        }
    }

    private void handleOutOfFuel(Plane plane) throws IOException {
        plane.destroyPlane();
        controlTower.removePlaneFromSpace(plane);
        log.info("Plane [{}]: out of fuel. Disappeared from the radar", plane.getFlightNumber());
    }
}


====================
FILE: Client.java

package com.jakub.bone.client;

import lombok.Getter;
import lombok.extern.log4j.Log4j2;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

@Log4j2
@Getter
public class Client {
    private Socket socket;
    protected ObjectOutputStream out;
    protected ObjectInputStream in;
    private int port;
    private String ip;
    protected boolean isConnected;

    public Client(String ip,int port) {
        this.ip = ip;
        this.port = port;
    }

    protected void startConnection() {
        try {
            this.socket = new Socket(ip, port);
            this.out = new ObjectOutputStream(socket.getOutputStream());
            this.in = new ObjectInputStream(socket.getInputStream());
            this.isConnected = true;
            log.debug("Connection established successfully");
        } catch (IOException ex) {
            log.error("Failed to connect to server at {}:{} - {}", ip, port, ex.getMessage());
        }
    }

    protected void stopConnection() {
        try {
            if(socket != null && !socket.isClosed()){
                socket.close();
            }
            if (out != null) {
                out.close();
            }
            if (in != null) {
                in.close();
            }
        } catch (IOException ex) {
            log.error("Error occurred while closing resources: {}", ex.getMessage());
        }
    }
}

====================
FILE: PlaneClient.java

package com.jakub.bone.client;

import com.jakub.bone.application.PlaneHandler;
import lombok.Getter;
import com.jakub.bone.utills.Messenger;
import lombok.extern.log4j.Log4j2;
import com.jakub.bone.domain.plane.Plane;
import org.apache.logging.log4j.ThreadContext;

import java.io.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;


@Log4j2
@Getter
public class PlaneClient extends Client implements Runnable {
    private Plane plane;
    private Messenger messenger;
    private PlaneInstructionHandler instructionHandler;
    private PlaneCommunicationService communicationService;

    public PlaneClient(String ip, int port) {
        super(ip, port);
        this.plane = new Plane(generateFlightNumber());
        this.messenger = new Messenger();
        log.debug("PlaneClient created for Plane [{}] at IP: {}, Port: {}", plane.getFlightNumber(), ip, port);
    }

    @Override
    public void run() {
        connectAndHandle();
    }

    private void connectAndHandle(){
        ThreadContext.put("type", "Client");
        try {
            establishConnection();
            initializeServices();
            communicationService.sendInitialData();
            processInstructions();
        } catch (IOException | ClassNotFoundException ex) {
            log.error("PlaneClient [{}]: encountered an error: {}", plane.getFlightNumber(), ex.getMessage());
        } finally {
            closeConnection();
        }
    }

    private void establishConnection() throws IOException {
        startConnection();
        if (!isConnected) {
            throw new IOException("Unable to establish connection to the server");
        }
        log.info("PlaneClient [{}]: connected to server", plane.getFlightNumber());
    }

    private void initializeServices(){
        this.communicationService = new PlaneCommunicationService(plane, messenger, out);
        this.instructionHandler = new PlaneInstructionHandler(plane, messenger, in, out);
    }

    private void processInstructions() throws IOException, ClassNotFoundException {
        while (!instructionHandler.isProcessCompleted()) {
            if(!communicationService.sendFuelLevel() || !communicationService.sendLocation()){
                log.error("Plane [{}]: lost communication due to fuel or location issues", plane.getFlightNumber());
                return;
            }

            PlaneHandler.AirportInstruction instruction = messenger.receiveAndParse(in, PlaneHandler.AirportInstruction.class);
            instructionHandler.processInstruction(instruction);

            if(plane.isDestroyed()){
                log.info("Plane [{}]: has destroyed", plane.getFlightNumber());
                return;
            }
        }
    }

    public String generateFlightNumber() {
        String[] airlineCodes = {"MH", "AA", "BA", "LH", "AF", "EK", "QR", "KL", "UA", "DL"};
        String code = airlineCodes[ThreadLocalRandom.current().nextInt(airlineCodes.length)];
        int number = ThreadLocalRandom.current().nextInt(100, 999);
        return code + number;
    }

    private void closeConnection() {
        stopConnection();
        log.debug("Plane [{}]: connection stopped", plane.getFlightNumber());

    }

    public static void main(String[] args) throws IOException {
        int numberOfClients = 100;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfClients);

        for (int i = 0; i < numberOfClients; i++) {
            PlaneClient client = new PlaneClient("localhost", 5000);
            try{
                Thread.sleep(5000);
            } catch (InterruptedException ex){
                ex.printStackTrace();
            }
            executorService.execute(client);
        }
        executorService.shutdown();
    }
}

====================
FILE: PlaneCommunicationService.java

package com.jakub.bone.client;

import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.domain.plane.Plane;
import com.jakub.bone.utills.Messenger;
import lombok.extern.log4j.Log4j2;

import java.io.IOException;
import java.io.ObjectOutputStream;

@Log4j2
public class PlaneCommunicationService {
    private Plane plane;
    private Messenger messenger;
    private ObjectOutputStream out;

    public PlaneCommunicationService(Plane plane, Messenger messenger, ObjectOutputStream out) {
        this.plane = plane;
        this.messenger = messenger;
        this.out = out;
    }

    public void sendInitialData() throws IOException {
        sendData(plane);
    }

    public boolean sendFuelLevel() throws IOException {
        double fuelLevel = plane.getFuelManager().getFuelLevel();
        sendData(fuelLevel);

        if (plane.getFuelManager().isOutOfFuel()) {
            log.info("Plane [{}]: out of fuel. Collision detected", plane.getFlightNumber());
            return false;
        }
        return true;
    }

    public boolean sendLocation() throws IOException {
        Location location = plane.getNavigator().getLocation();

        if(location == null) {
            log.info("Plane [{}]: disappeared from the radar", plane.getFlightNumber());
            return false;
        }

        sendData(location);
        return true;
    }

    private void sendData(Object data) throws IOException {
        messenger.send(data, out);
        out.flush();
    }
}

====================
FILE: PlaneInstructionHandler.java

package com.jakub.bone.client;

import com.jakub.bone.domain.airport.Runway;
import com.jakub.bone.application.PlaneHandler;
import lombok.Getter;
import com.jakub.bone.domain.plane.Plane;
import com.jakub.bone.utills.Messenger;
import lombok.extern.log4j.Log4j2;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import static com.jakub.bone.application.PlaneHandler.AirportInstruction.*;

@Log4j2
@Getter
public class PlaneInstructionHandler {
    private Plane plane;
    private Messenger messenger;
    private ObjectInputStream in;
    private ObjectOutputStream out;
    private boolean isProcessCompleted;
    private PlaneCommunicationService communicationService;
    private boolean descentLogged;
    private boolean holdPatternLogged;

    public PlaneInstructionHandler(Plane plane, Messenger messenger, ObjectInputStream in, ObjectOutputStream out) {
        this.plane = plane;
        this.messenger = messenger;
        this.in = in;
        this.out = out;
        this.communicationService = new PlaneCommunicationService(plane, messenger, out);
        this.descentLogged = false;
        this.holdPatternLogged = false;
    }

    public void processInstruction(PlaneHandler.AirportInstruction instruction) throws IOException, ClassNotFoundException {
        switch (instruction) {
            case DESCENT -> handleDescent();
            case HOLD_PATTERN -> handleHoldPattern();
            case LAND -> handleLanding();
            case COLLISION -> handleCollision();
            case FULL -> abortProcess("No capacity in the airspace");
            case RISK_ZONE -> abortProcess("Initial location occupied");
            default -> log.warn("Plane [{}]: Unknown instruction: {}", plane.getFlightNumber(), instruction);
        }
    }

    private void handleLanding() throws IOException, ClassNotFoundException {
        Runway runway = messenger.receiveAndParse(in, Runway.class);
        plane.setLandingPhase(runway);

        log.info("Plane [{}]: instructed to {} on runway {{}]", plane.getFlightNumber(), LAND, runway.getId());
        performLanding(runway);
    }

    private void performLanding(Runway runway) throws IOException {
        while (!isProcessCompleted) {
            if(!communicationService.sendFuelLevel()){
                return;
            }

            plane.land(runway);

            if(!communicationService.sendLocation()){
                return;
            }

            if (plane.isLanded()) {
                isProcessCompleted = true;
                log.info("Plane [{}]: successfully landed on runway {{}]", plane.getFlightNumber(), runway.getId());
            }
        }
    }

    private void handleDescent() {
        if (!descentLogged) {
            log.info("Plane [{}]: instructed to {}", plane.getFlightNumber(), DESCENT);
            descentLogged = true;
        }
        plane.descend();
    }

    private void handleHoldPattern() {
        if (!holdPatternLogged) {
            log.info("Plane [{}]: instructed to {}", plane.getFlightNumber(), HOLD_PATTERN);
            holdPatternLogged = true;
        }
        plane.hold();
    }

    private void abortProcess(String message) {
        log.info("Plane [{}]: {} Redirecting", plane.getFlightNumber(), message);
        isProcessCompleted = true;
    }

    private void handleCollision() {
        log.info("Plane [{}]: {} detected", plane.getFlightNumber(), COLLISION);
        plane.destroyPlane();
        isProcessCompleted = true;
    }
}

====================
FILE: SimulationLauncher.java

package com.jakub.bone.core;

import com.jakub.bone.ui.utills.SceneRenderer;
import com.jakub.bone.application.ControlTower;
import com.jakub.bone.client.PlaneClient;
import com.jakub.bone.database.AirportDatabase;
import javafx.application.Application;
import javafx.stage.Stage;
import com.jakub.bone.server.AirportServer;

import java.io.IOException;
import java.sql.SQLException;

public class SimulationLauncher extends Application {
    private ControlTower controller;
    private AirportServer airportServer;
    private AirportDatabase database;
    @Override
    public void start(Stage primaryStage) throws Exception, SQLException {
        this.database = new AirportDatabase();
        this.controller = new ControlTower(database);
        this.airportServer = null;
        Thread serverThread = new Thread(() -> {
            try {
                airportServer = new AirportServer(controller);
                airportServer.startServer(5000);
            } catch (SQLException e) {
                throw new RuntimeException(e);
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        serverThread.isDaemon();
        serverThread.start();

        int clientsNumber = 10000;

        new Thread(() -> {
            for (int i = 0; i < clientsNumber; i++) {
                PlaneClient client = new PlaneClient("localhost", 5000);
                new Thread(client).start();
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        SceneRenderer visualization = new SceneRenderer(controller);
        visualization.start(primaryStage);
    }

    public static void main(String[] args) {
        launch(args);
    }
}



====================
FILE: AirportDatabase.java

package com.jakub.bone.database;

import lombok.Getter;
import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

@Getter
@Log4j2
public class AirportDatabase {
    private final String USER = "airport";
    private final String PASSWORD = "plane123";
    private final String DATABASE = "airport_system";
    private final String URL = String.format("jdbc:postgresql://localhost:%d/%s", 5432, DATABASE);;
    private final DSLContext CONTEXT;
    private final DatabaseSchema SCHEMA;
    private final PlaneRepository PLANE_DAO;
    private final CollisionRepository COLLISION_DAO;
    private Connection connection;

    public AirportDatabase() throws SQLException {
        this.connection = getDatabaseConnection();
        this.CONTEXT = DSL.using(connection);
        this.PLANE_DAO = new PlaneRepository(CONTEXT);
        this.COLLISION_DAO = new CollisionRepository(CONTEXT);
        this.SCHEMA = new DatabaseSchema(CONTEXT);
    }

    public Connection getDatabaseConnection() throws SQLException {
        if (connection != null && !connection.isClosed()) {
            return connection;
        }
        try {
            this.connection = DriverManager.getConnection(URL, USER, PASSWORD);
            log.info("Connection established successfully with database '{}' on port {}", DATABASE, 5432);
        } catch (SQLException ex) {
            log.error("Failed to establish connection to the database '{}'. Error: {}", DATABASE, ex.getMessage(), ex);
            throw ex;
        }
        return connection;
    }

    public void closeConnection() {
        if (connection != null) {
            try {
                connection.close();
                log.info("Connection to database '{}' closed successfully.", DATABASE);
            } catch (SQLException ex) {
                log.error("Failed to close connection. Error: {}", ex.getMessage(), ex);
            }
        }
    }
}

====================
FILE: CollisionRepository.java

package com.jakub.bone.database;

import org.jooq.DSLContext;

import java.time.LocalDateTime;

import static org.jooq.impl.DSL.*;

public class CollisionRepository {
    private final DSLContext CONTEXT;
    public CollisionRepository(DSLContext CONTEXT) {
        this.CONTEXT = CONTEXT;
    }

    public void registerCollisionToDB(String [] planesIds){
        CONTEXT.insertInto(table("collisions"),
                    field("involved_planes"),
                    field("time"))
                .values(planesIds,
                        LocalDateTime.now())
                .execute();
    }
}

====================
FILE: DatabaseSchema.java

package com.jakub.bone.database;

import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;

public class DatabaseSchema {
    private final DSLContext CONTEXT;
    public DatabaseSchema(DSLContext dsl) {
        this.CONTEXT = dsl;
        createTables();
    }

    public void createTables() {
        CONTEXT.createTableIfNotExists("planes")
                .column("id", SQLDataType.INTEGER.identity(true))
                .column("flight_number", SQLDataType.VARCHAR)
                .column("start_time", SQLDataType.LOCALDATETIME(1).nullable(false))
                .column("landing_time", SQLDataType.LOCALDATETIME(1))
                .constraints(
                        DSL.constraint("PK_PLANES").primaryKey("id"))
                .execute();

        CONTEXT.createTableIfNotExists("collisions")
                .column("id", SQLDataType.INTEGER.identity(true))
                .column("involved_planes", SQLDataType.INTEGER.getArrayDataType())
                .column("time", SQLDataType.LOCALDATETIME(1))
                .constraints(
                        DSL.constraint("PK_COLLISIONS").primaryKey("id"))
                .execute();
    }

    public void clearTables(){
        CONTEXT.truncate("planes").execute();
        CONTEXT.truncate("collisions").execute();
    }
}

====================
FILE: PlaneRepository.java

package com.jakub.bone.database;

import org.jooq.DSLContext;
import com.jakub.bone.domain.plane.Plane;

import java.time.LocalDateTime;

import static org.jooq.impl.DSL.*;

public class PlaneRepository {
    private final DSLContext CONTEXT;
    public PlaneRepository(DSLContext context) {
        CONTEXT = context;
    }

    public void registerPlaneInDB(Plane plane){
        CONTEXT.insertInto(table("planes"),
                    field("flight_number"),
                    field("start_time"))
                .values(plane.getFlightNumber(),
                    LocalDateTime.now())
                .execute();
    }

    public void registerLandingInDB(Plane plane){
        CONTEXT.update(table("planes"))
                .set(field("landing_time"), LocalDateTime.now())
                .where(field("flight_number").eq(plane.getFlightNumber()))
                .execute();
    }
}

====================
FILE: Airport.java

package com.jakub.bone.domain.airport;

import lombok.Getter;
import com.jakub.bone.utills.Constant;

@Getter
public class Airport {
    public static Runway runway2;
    public static Runway runway1;
    public Airport() {
        this.runway1 = Runway.builder()
                .id("R-1")
                .landingPoint(Constant.LANDING_POINT_RUNWAY_1)
                .corridor(new Corridor("C-1", Constant.ENTRY_POINT_CORRIDOR_1, Constant.FINAL_APPROACH_CORRIDOR_1))
                .available(true)
                .build();
        this.runway2 = Runway.builder()
                .id("R-2")
                .landingPoint(Constant.LANDING_POINT_RUNWAY_2)
                .corridor(new Corridor("C-2", Constant.ENTRY_POINT_CORRIDOR_2, Constant.FINAL_APPROACH_CORRIDOR_2))
                .available(true)
                .build();
    }
}

====================
FILE: Corridor.java

package com.jakub.bone.domain.airport;

import lombok.Getter;

import java.io.Serializable;

@Getter
public class Corridor implements Serializable {
    private String id;
    private Location entryPoint;
    private Location finalApproachPoint;

    public Corridor(String id, Location entryPoint, Location finalApproachPoint) {
        this.id = id;
        this.entryPoint = entryPoint;
        this.finalApproachPoint = finalApproachPoint;
    }
}

====================
FILE: Location.java

package com.jakub.bone.domain.airport;

import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;
import java.util.Objects;

@Getter
@Setter
public class Location implements Serializable {
    int x;
    int y;
    int altitude;
    public Location(int x, int y, int altitude) {
        this.x = x;
        this.y = y;
        this.altitude = altitude;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Location location = (Location) obj;
        return x == location.x && y == location.y && altitude == location.altitude;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y, altitude);
    }
}

====================
FILE: Runway.java

package com.jakub.bone.domain.airport;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

import java.io.Serializable;

@Log4j2
@Getter
@Setter
@Builder
public class Runway implements Serializable {
    private String id;
    private Location landingPoint;
    private Corridor corridor;
    private boolean available;

    public Runway(String id, Location landingPoint, Corridor corridor, boolean available) {
        this.id = id;
        this.landingPoint = landingPoint;
        this.corridor = corridor;
        this.available = available;
    }
}

====================
FILE: FuelManager.java

package com.jakub.bone.domain.plane;

import lombok.Getter;
import lombok.Setter;

import static com.jakub.bone.utills.Constant.CONSUMPTION_PER_SECOND;
import static com.jakub.bone.utills.Constant.INITIAL_FUEL_LEVEL;

@Getter
@Setter
public class FuelManager {
    private double fuelLevel;
    public FuelManager() {
        this.fuelLevel = INITIAL_FUEL_LEVEL;
    }

    public void burnFuel() {
        fuelLevel -= CONSUMPTION_PER_SECOND;
    }

    public boolean isOutOfFuel() {
        return fuelLevel <= 0;
    }
}

====================
FILE: Navigator.java

package com.jakub.bone.domain.plane;

import com.jakub.bone.domain.airport.Location;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import com.jakub.bone.utills.WaypointGenerator;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

import static com.jakub.bone.utills.Constant.MAX_ALTITUDE;
import static com.jakub.bone.utills.Constant.MIN_ALTITUDE;

@Getter
@Setter
@Log4j2
public class Navigator {
    private List<Location> waypoints;
    private FuelManager fuelManager;
    private int currentIndex;
    private Location location;
    private boolean isFirstMove;

    public Navigator(FuelManager fuelManager) {
        this.waypoints = WaypointGenerator.getDescentWaypoints();
        this.fuelManager = fuelManager;
        this.currentIndex = 315;
        this.location = waypoints.get(currentIndex);
        this.isFirstMove = true;
        //spawnPlane();
    }

    public void move(String id) {
        if (currentIndex < waypoints.size()) {
            updateLocation(waypoints.get(currentIndex), id);
            currentIndex++;
        }
        fuelManager.burnFuel();
    }

    public boolean isAtLastWaypoint(){
        return currentIndex == waypoints.size();
    }

    public void updateLocation(Location location, String id) {
        if(!isFirstMove){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
            }
        }
        this.isFirstMove = false;
        this.location = location;
    }

    private void spawnPlane() {
        List<Location> waypointsToSpawn = waypoints.stream()
                .filter(wp -> wp.getAltitude() >= MIN_ALTITUDE && wp.getAltitude() <= MAX_ALTITUDE)
                .collect(Collectors.toList());

        Random random = new Random();
        this.currentIndex = random.nextInt(waypointsToSpawn.size());
        Location initialWaypoint = waypointsToSpawn.get(currentIndex);
        this.location = initialWaypoint;
    }

    public List <Location> getRiskZoneWaypoints(){
        List <Location> nearWaypoints = new ArrayList<>();
        nearWaypoints.add(waypoints.get(currentIndex - 1));
        nearWaypoints.add(waypoints.get(currentIndex - 2));
        nearWaypoints.add(waypoints.get(currentIndex - 3));
        nearWaypoints.add(waypoints.get(currentIndex));
        nearWaypoints.add(waypoints.get(currentIndex + 1));
        nearWaypoints.add(waypoints.get(currentIndex + 2));
        nearWaypoints.add(waypoints.get(currentIndex + 3));
        return nearWaypoints;
    }
}

====================
FILE: Plane.java

package com.jakub.bone.domain.plane;

import com.jakub.bone.domain.airport.Runway;
import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.utills.WaypointGenerator;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

import java.io.Serializable;
import java.util.List;

@Log4j2
@Getter
@Setter
public class Plane implements Serializable {
    public enum FlightPhase {
        DESCENDING, HOLDING, LANDING
    }
    private String flightNumber;
    private boolean landed;
    private List <Location> waypoints;
    private boolean isDestroyed;
    private FuelManager fuelManager;
    private Navigator navigator;
    private FlightPhase phase;
    private Runway assignedRunway;

    public Plane(String flightNumber) {
        this.flightNumber = flightNumber;
        this.phase = FlightPhase.DESCENDING;
        this.fuelManager = new FuelManager();
        this.navigator = new Navigator(fuelManager);
        this.isDestroyed = false;
        this.landed = false;
        this.assignedRunway = null;
    }

    public void descend(){
        navigator.move(flightNumber);
        if (navigator.isAtLastWaypoint()) {
            setPhase(FlightPhase.HOLDING);
            navigator.setWaypoints(WaypointGenerator.getHoldingPatternWaypoints());
            navigator.setCurrentIndex(0);
        }
    }

    public void hold(){
        setPhase(FlightPhase.HOLDING);
        navigator.move(flightNumber);
        if (navigator.isAtLastWaypoint()) {
            navigator.setCurrentIndex(0);
        }
    }

    public void land(Runway runway){
        assignedRunway = runway;
        navigator.move(flightNumber);
        if(navigator.isAtLastWaypoint()) {
            navigator.setLocation(runway.getLandingPoint());
            landed = true;
        }
    }

    public void setLandingPhase(Runway runway) {
        setPhase(FlightPhase.LANDING);
        navigator.setWaypoints(WaypointGenerator.getLandingWaypoints(runway));
        navigator.setCurrentIndex(0);
    }

    public void destroyPlane() {
        this.isDestroyed = true;
    }
}

====================
FILE: DefaultCatalog.java

/*
 * This file is generated by jOOQ.
 */
package jooq;


import java.util.Arrays;
import java.util.List;

import org.jooq.Constants;
import org.jooq.Schema;
import org.jooq.impl.CatalogImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class DefaultCatalog extends CatalogImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>DEFAULT_CATALOG</code>
     */
    public static final DefaultCatalog DEFAULT_CATALOG = new DefaultCatalog();

    /**
     * The schema <code>public</code>.
     */
    public final Public PUBLIC = Public.PUBLIC;

    /**
     * No further instances allowed
     */
    private DefaultCatalog() {
        super("");
    }

    @Override
    public final List<Schema> getSchemas() {
        return Arrays.asList(
            Public.PUBLIC
        );
    }

    /**
     * A reference to the 3.19 minor release of the code generator. If this
     * doesn't compile, it's because the runtime library uses an older minor
     * release, namely: 3.19. You can turn off the generation of this reference
     * by specifying /configuration/generator/generate/jooqVersionReference
     */
    private static final String REQUIRE_RUNTIME_JOOQ_VERSION = Constants.VERSION_3_19;
}

====================
FILE: Keys.java

/*
 * This file is generated by jOOQ.
 */
package jooq;


import jooq.tables.Collisions;
import jooq.tables.Planes;
import jooq.tables.records.CollisionsRecord;
import jooq.tables.records.PlanesRecord;

import org.jooq.TableField;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;


/**
 * A class modelling foreign key relationships and constraints of tables in
 * public.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class Keys {

    // -------------------------------------------------------------------------
    // UNIQUE and PRIMARY KEY definitions
    // -------------------------------------------------------------------------

    public static final UniqueKey<CollisionsRecord> PK_COLLISIONS = Internal.createUniqueKey(Collisions.COLLISIONS, DSL.name("PK_COLLISIONS"), new TableField[] { Collisions.COLLISIONS.ID }, true);
    public static final UniqueKey<PlanesRecord> PK_PLANES = Internal.createUniqueKey(Planes.PLANES, DSL.name("PK_PLANES"), new TableField[] { Planes.PLANES.ID }, true);
}

====================
FILE: Public.java

/*
 * This file is generated by jOOQ.
 */
package jooq;


import java.util.Arrays;
import java.util.List;

import jooq.tables.Collisions;
import jooq.tables.Planes;

import org.jooq.Catalog;
import org.jooq.Table;
import org.jooq.impl.SchemaImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class Public extends SchemaImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public</code>
     */
    public static final Public PUBLIC = new Public();

    /**
     * The table <code>public.collisions</code>.
     */
    public final Collisions COLLISIONS = Collisions.COLLISIONS;

    /**
     * The table <code>public.planes</code>.
     */
    public final Planes PLANES = Planes.PLANES;

    /**
     * No further instances allowed
     */
    private Public() {
        super("public", null);
    }


    @Override
    public Catalog getCatalog() {
        return DefaultCatalog.DEFAULT_CATALOG;
    }

    @Override
    public final List<Table<?>> getTables() {
        return Arrays.asList(
            Collisions.COLLISIONS,
            Planes.PLANES
        );
    }
}

====================
FILE: Collisions.java

/*
 * This file is generated by jOOQ.
 */
package jooq.tables;


import java.time.LocalDateTime;
import java.util.Collection;

import jooq.Keys;
import jooq.Public;
import jooq.tables.records.CollisionsRecord;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.Identity;
import org.jooq.Name;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class Collisions extends TableImpl<CollisionsRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.collisions</code>
     */
    public static final Collisions COLLISIONS = new Collisions();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<CollisionsRecord> getRecordType() {
        return CollisionsRecord.class;
    }

    /**
     * The column <code>public.collisions.id</code>.
     */
    public final TableField<CollisionsRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    /**
     * The column <code>public.collisions.involved_planes</code>.
     */
    public final TableField<CollisionsRecord, String[]> INVOLVED_PLANES = createField(DSL.name("involved_planes"), SQLDataType.VARCHAR.array(), this, "");

    /**
     * The column <code>public.collisions.time</code>.
     */
    public final TableField<CollisionsRecord, LocalDateTime> TIME = createField(DSL.name("time"), SQLDataType.LOCALDATETIME(1), this, "");

    private Collisions(Name alias, Table<CollisionsRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private Collisions(Name alias, Table<CollisionsRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>public.collisions</code> table reference
     */
    public Collisions(String alias) {
        this(DSL.name(alias), COLLISIONS);
    }

    /**
     * Create an aliased <code>public.collisions</code> table reference
     */
    public Collisions(Name alias) {
        this(alias, COLLISIONS);
    }

    /**
     * Create a <code>public.collisions</code> table reference
     */
    public Collisions() {
        this(DSL.name("collisions"), null);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public Identity<CollisionsRecord, Integer> getIdentity() {
        return (Identity<CollisionsRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<CollisionsRecord> getPrimaryKey() {
        return Keys.PK_COLLISIONS;
    }

    @Override
    public Collisions as(String alias) {
        return new Collisions(DSL.name(alias), this);
    }

    @Override
    public Collisions as(Name alias) {
        return new Collisions(alias, this);
    }

    @Override
    public Collisions as(Table<?> alias) {
        return new Collisions(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public Collisions rename(String name) {
        return new Collisions(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Collisions rename(Name name) {
        return new Collisions(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public Collisions rename(Table<?> name) {
        return new Collisions(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions where(Condition condition) {
        return new Collisions(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Collisions where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Collisions where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Collisions where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Collisions where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Collisions whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}

====================
FILE: Planes.java

/*
 * This file is generated by jOOQ.
 */
package jooq.tables;


import java.time.LocalDateTime;
import java.util.Collection;

import jooq.Keys;
import jooq.Public;
import jooq.tables.records.PlanesRecord;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.Identity;
import org.jooq.Name;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class Planes extends TableImpl<PlanesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.planes</code>
     */
    public static final Planes PLANES = new Planes();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<PlanesRecord> getRecordType() {
        return PlanesRecord.class;
    }

    /**
     * The column <code>public.planes.id</code>.
     */
    public final TableField<PlanesRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    /**
     * The column <code>public.planes.flight_number</code>.
     */
    public final TableField<PlanesRecord, String> FLIGHT_NUMBER = createField(DSL.name("flight_number"), SQLDataType.VARCHAR, this, "");

    /**
     * The column <code>public.planes.start_time</code>.
     */
    public final TableField<PlanesRecord, LocalDateTime> START_TIME = createField(DSL.name("start_time"), SQLDataType.LOCALDATETIME(1).nullable(false), this, "");

    /**
     * The column <code>public.planes.landing_time</code>.
     */
    public final TableField<PlanesRecord, LocalDateTime> LANDING_TIME = createField(DSL.name("landing_time"), SQLDataType.LOCALDATETIME(1), this, "");

    private Planes(Name alias, Table<PlanesRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private Planes(Name alias, Table<PlanesRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>public.planes</code> table reference
     */
    public Planes(String alias) {
        this(DSL.name(alias), PLANES);
    }

    /**
     * Create an aliased <code>public.planes</code> table reference
     */
    public Planes(Name alias) {
        this(alias, PLANES);
    }

    /**
     * Create a <code>public.planes</code> table reference
     */
    public Planes() {
        this(DSL.name("planes"), null);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public Identity<PlanesRecord, Integer> getIdentity() {
        return (Identity<PlanesRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<PlanesRecord> getPrimaryKey() {
        return Keys.PK_PLANES;
    }

    @Override
    public Planes as(String alias) {
        return new Planes(DSL.name(alias), this);
    }

    @Override
    public Planes as(Name alias) {
        return new Planes(alias, this);
    }

    @Override
    public Planes as(Table<?> alias) {
        return new Planes(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public Planes rename(String name) {
        return new Planes(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Planes rename(Name name) {
        return new Planes(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public Planes rename(Table<?> name) {
        return new Planes(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes where(Condition condition) {
        return new Planes(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Planes where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Planes where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Planes where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Planes where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Planes whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}

====================
FILE: CollisionsRecord.java

/*
 * This file is generated by jOOQ.
 */
package jooq.tables.records;


import java.time.LocalDateTime;

import jooq.tables.Collisions;

import org.jooq.Record1;
import org.jooq.impl.UpdatableRecordImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class CollisionsRecord extends UpdatableRecordImpl<CollisionsRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>public.collisions.id</code>.
     */
    public void setId(Integer value) {
        set(0, value);
    }

    /**
     * Getter for <code>public.collisions.id</code>.
     */
    public Integer getId() {
        return (Integer) get(0);
    }

    /**
     * Setter for <code>public.collisions.involved_planes</code>.
     */
    public void setInvolvedPlanes(String[] value) {
        set(1, value);
    }

    /**
     * Getter for <code>public.collisions.involved_planes</code>.
     */
    public String[] getInvolvedPlanes() {
        return (String[]) get(1);
    }

    /**
     * Setter for <code>public.collisions.time</code>.
     */
    public void setTime(LocalDateTime value) {
        set(2, value);
    }

    /**
     * Getter for <code>public.collisions.time</code>.
     */
    public LocalDateTime getTime() {
        return (LocalDateTime) get(2);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached CollisionsRecord
     */
    public CollisionsRecord() {
        super(Collisions.COLLISIONS);
    }

    /**
     * Create a detached, initialised CollisionsRecord
     */
    public CollisionsRecord(Integer id, String[] involvedPlanes, LocalDateTime time) {
        super(Collisions.COLLISIONS);

        setId(id);
        setInvolvedPlanes(involvedPlanes);
        setTime(time);
        resetChangedOnNotNull();
    }
}

====================
FILE: PlanesRecord.java

/*
 * This file is generated by jOOQ.
 */
package jooq.tables.records;


import java.time.LocalDateTime;

import jooq.tables.Planes;

import org.jooq.Record1;
import org.jooq.impl.UpdatableRecordImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class PlanesRecord extends UpdatableRecordImpl<PlanesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>public.planes.id</code>.
     */
    public void setId(Integer value) {
        set(0, value);
    }

    /**
     * Getter for <code>public.planes.id</code>.
     */
    public Integer getId() {
        return (Integer) get(0);
    }

    /**
     * Setter for <code>public.planes.flight_number</code>.
     */
    public void setFlightNumber(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>public.planes.flight_number</code>.
     */
    public String getFlightNumber() {
        return (String) get(1);
    }

    /**
     * Setter for <code>public.planes.start_time</code>.
     */
    public void setStartTime(LocalDateTime value) {
        set(2, value);
    }

    /**
     * Getter for <code>public.planes.start_time</code>.
     */
    public LocalDateTime getStartTime() {
        return (LocalDateTime) get(2);
    }

    /**
     * Setter for <code>public.planes.landing_time</code>.
     */
    public void setLandingTime(LocalDateTime value) {
        set(3, value);
    }

    /**
     * Getter for <code>public.planes.landing_time</code>.
     */
    public LocalDateTime getLandingTime() {
        return (LocalDateTime) get(3);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached PlanesRecord
     */
    public PlanesRecord() {
        super(Planes.PLANES);
    }

    /**
     * Create a detached, initialised PlanesRecord
     */
    public PlanesRecord(Integer id, String flightNumber, LocalDateTime startTime, LocalDateTime landingTime) {
        super(Planes.PLANES);

        setId(id);
        setFlightNumber(flightNumber);
        setStartTime(startTime);
        setLandingTime(landingTime);
        resetChangedOnNotNull();
    }
}

====================
FILE: Tables.java

/*
 * This file is generated by jOOQ.
 */
package jooq;


import jooq.tables.Collisions;
import jooq.tables.Planes;


/**
 * Convenience access to all tables in public.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class Tables {

    /**
     * The table <code>public.collisions</code>.
     */
    public static final Collisions COLLISIONS = Collisions.COLLISIONS;

    /**
     * The table <code>public.planes</code>.
     */
    public static final Planes PLANES = Planes.PLANES;
}

====================
FILE: AirportServer.java

package com.jakub.bone.server;

import com.jakub.bone.application.ControlTower;
import com.jakub.bone.domain.airport.Airport;
import com.jakub.bone.application.CollisionDetector;
import com.jakub.bone.database.AirportDatabase;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;
import com.jakub.bone.application.PlaneHandler;
import org.apache.logging.log4j.ThreadContext;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.SQLException;

@Log4j2
@Getter
public class AirportServer  {
    private ServerSocket serverSocket;
    private ControlTower controlTower;
    private Airport airport;

    public AirportServer(ControlTower controller) throws SQLException {
        this.controlTower = controller;
        this.airport = new Airport();
    }

    public void startServer(int port) throws IOException {
        ThreadContext.put("type", "Server");
        try {
            this.serverSocket = new ServerSocket(port);
            log.info("Server started");

            new CollisionDetector(controlTower).start();

            log.info("Collision detector started");

            while (true) {
                try {
                    Socket clientSocket = serverSocket.accept();
                    if (clientSocket != null) {
                        log.debug("Server connected with client at port: {}", port);
                        new PlaneHandler(clientSocket, controlTower, airport).start();
                    }
                } catch (Exception ex) {
                    if(serverSocket.isClosed()){
                        return;
                    }
                    log.error("Error handling client connection: {}", ex.getMessage(), ex);
                }
            }
        } catch (IOException ex) {
            log.error("Failed to start AirportServer on port {}: {}", port, ex.getMessage(), ex);
        }
    }

    public void stopServer() {
        try {
            if (serverSocket != null && !serverSocket.isClosed()) {
                serverSocket.close();
                log.info("Server closed successfully");
            }
        } catch (IOException ex) {
            log.error("Error occurred while closing server socket: {}", ex.getMessage());
        }
    }

    public static void main(String[] args) throws IOException, SQLException {
        AirportDatabase database = new AirportDatabase();
        ControlTower controlTower = new ControlTower(database);
        AirportServer airportServer = new AirportServer(controlTower);
        airportServer.startServer(5000);
        airportServer.stopServer();
    }
}

====================
FILE: AirspaceModel.java

package com.jakub.bone.ui.model;

import javafx.scene.image.Image;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import lombok.Getter;

@Getter
public class AirspaceModel {
    private Rectangle floor;
    private Rectangle leftWall;
    private Rectangle rightWall;

    public AirspaceModel() {
        setupFloor();
        setupLeftWall();
        setupRightWall();
    }

    private void setupFloor() {
        Image image = new Image(getClass().getResource("/images/wall.png").toExternalForm());
        this.floor = createWall(6000, 6000, image);
        this.floor.getTransforms().add(new Rotate(90, Rotate.X_AXIS));
        this.floor.setTranslateX(- 3000);
        this.floor.setTranslateY(0);
        this.floor.setTranslateZ(- 3000) ;
    }

    private void setupLeftWall() {
        Image image = new Image(getClass().getResource("/images/newYork.png").toExternalForm());
        this.leftWall = createWall(6000, 2500, image);
        this.leftWall.getTransforms().add(new Rotate(180, Rotate.X_AXIS));
        this.leftWall.setTranslateX(-3000);
        this.leftWall.setTranslateY(0);
        this.leftWall.setTranslateZ(3000);
    }

    private void setupRightWall() {
        Image image = new Image(getClass().getResource("/images/departures.png").toExternalForm());
        this.rightWall = createWall(2500, 6000, image);
        this.rightWall.getTransforms().add(new Rotate(-90, Rotate.X_AXIS));
        this.rightWall.getTransforms().add(new Rotate(90, Rotate.Y_AXIS));
        this.rightWall.setTranslateX(3000);
        this.rightWall.setTranslateY(0);
        this.rightWall.setTranslateZ(3000);
    }

    private Rectangle createWall(int width, int height, Image image) {
        Rectangle wall = new Rectangle(width, height);
        ImagePattern wallPattern = new ImagePattern(image);
        wall.setFill(wallPattern);
        return wall;
    }
}

====================
FILE: PlaneModel.java

package com.jakub.bone.ui.model;

import javafx.animation.Interpolator;
import javafx.animation.TranslateTransition;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.shape.MeshView;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;
import com.jakub.bone.domain.airport.Location;
import lombok.Getter;
import com.jakub.bone.domain.plane.Plane;

import com.interactivemesh.jfx.importer.obj.ObjModelImporter;


@Getter
public class PlaneModel {
    private Plane plane;
    private Group planeGroup;
    private MeshView[] meshViews;
    private Text label;

    public PlaneModel(Plane plane) {
        this.plane = plane;
        this.planeGroup = new Group();
        loadPlaneModel();
        createLabel();
        updatePosition(plane.getNavigator().getLocation());
    }
    public void loadPlaneModel() {
        ObjModelImporter importer = new ObjModelImporter();
        importer.read(getClass().getResource("/models/boeing737/boeingModel.obj"));

        meshViews = importer.getImport();
        planeGroup.getChildren().addAll(meshViews);
    }

    public void createLabel() {
        this.label = new Text();
        this.label.setFont(new Font(100));
        this.label.setFill(Color.WHITE);
        this.label.setText(plane.getFlightNumber());
    }

    private void updatePosition(Location location) {
        this.planeGroup.setTranslateX(location.getX() / 2.0);
        this.planeGroup.setTranslateY(-location.getAltitude() / 2.0);
        this.planeGroup.setTranslateZ(location.getY() / 2.0);

        this.label.setTranslateX(((location.getX() + 150)) / 2.0);
        this.label.setTranslateY(-((location.getAltitude() + 150)) / 2.0);
        this.label.setTranslateZ((location.getY()) / 2.0);
    }

    public void animateMovement(Location nextLocation) {
        double currentX = planeGroup.getTranslateX();
        double currentZ = planeGroup.getTranslateZ();

        double toPlaneX = nextLocation.getX() / 2.0;
        double toPlaneY = -nextLocation.getAltitude() / 2.0;
        double toPlaneZ = nextLocation.getY() / 2.0;

        calculateAndSetHeading(currentX, currentZ, toPlaneX, toPlaneZ);

        setInterpolation(planeGroup, toPlaneX, toPlaneY, toPlaneZ);
        setInterpolation(label, (nextLocation.getX() + 150) / 2.0, toPlaneY, (nextLocation.getY() + 150) / 2.0);
    }

    private void calculateAndSetHeading(double currentX, double currentZ, double targetX, double targetZ) {
        double deltaX = targetX - currentX;
        double deltaZ = targetZ - currentZ;

        double angleRadians = Math.atan2(deltaZ, deltaX);
        double angleDegrees = Math.toDegrees(angleRadians);

        double correctedAngle = angleDegrees + 90;

        Rotate headingRotate = new Rotate();
        headingRotate.setAxis(Rotate.Y_AXIS);
        headingRotate.setAngle(-correctedAngle);

        planeGroup.getTransforms().clear();
        planeGroup.getTransforms().add(headingRotate);
    }

    public void setInterpolation(Node node, double toX, double toY, double toZ) {
        TranslateTransition transition = new TranslateTransition();
        transition.setDuration(Duration.seconds(1));
        transition.setNode(node);
        transition.setToX(toX);
        transition.setToY(toY);
        transition.setToZ(toZ);
        transition.setInterpolator(Interpolator.LINEAR);
        transition.play();
    }

    public void setPlaneModelColor(Color color) {
        for (MeshView meshView : meshViews) {
            meshView.setMaterial(new PhongMaterial(color));
        }
        label.setFill(color);
    }
}

====================
FILE: RunwayModel.java

package com.jakub.bone.ui.model;

import com.jakub.bone.domain.airport.Runway;
import javafx.scene.image.Image;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import lombok.Getter;

import static com.jakub.bone.utills.Constant.RUNWAY_HEIGHT;
import static com.jakub.bone.utills.Constant.RUNWAY_WIDTH;

@Getter
public class RunwayModel {
    private Rectangle runwayRect;
    public RunwayModel(Runway runway) {
        this.runwayRect = new Rectangle(RUNWAY_WIDTH / 2.0, RUNWAY_HEIGHT/ 2.0);

        Image runwayImage = new Image(getClass().getResource("/images/runway.png").toExternalForm());
        ImagePattern runwayPattern = new ImagePattern(runwayImage);
        this.runwayRect.setFill(runwayPattern);

        this.runwayRect.getTransforms().add(new Rotate(90, Rotate.X_AXIS));
        this.runwayRect.setTranslateX(-1000);
        this.runwayRect.setTranslateY(0);
        this.runwayRect.setTranslateZ((runway.getLandingPoint().getY() / 2.0) - 250);
    }
}

====================
FILE: TerminalModel.java

package com.jakub.bone.ui.model;

import com.interactivemesh.jfx.importer.obj.ObjModelImporter;
import javafx.scene.Group;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.shape.MeshView;
import lombok.Getter;

@Getter
public class TerminalModel {
    private Group planeGroup;
    private PhongMaterial material;
    private MeshView[] meshViews;

    public TerminalModel(int transX, int transY, int transZ) {
        this.planeGroup = new Group();
        this.material = new PhongMaterial(Color.WHITE);
        loadTerminalModel(transX, transY, transZ);
    }

    public void loadTerminalModel(int transX, int transY, int transZ) {
        ObjModelImporter importer = new ObjModelImporter();
        importer.read(getClass().getResource("/models/terminal/terminal_main.obj"));

        this.meshViews = importer.getImport();
        for(MeshView meshView: meshViews){
            meshView.setMaterial(material);
        }
        planeGroup.getChildren().addAll(meshViews);
        setLocation(transX, transY, transZ);
    }

    private void setLocation(int transX, int transY, int transZ) {
        this.planeGroup.setTranslateX(transX);
        this.planeGroup.setTranslateY(- transY);
        this.planeGroup.setTranslateZ(transZ);
    }
}

====================
FILE: Camera.java

package com.jakub.bone.ui.utills;

import javafx.scene.Group;
import javafx.scene.PerspectiveCamera;

import javafx.scene.Scene;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import lombok.Getter;

@Getter
public class Camera {
    private PerspectiveCamera camera;
    private final Rotate rotateX;
    private final Rotate rotateY;
    private final Translate translate;

    public Camera() {
        this.camera = new PerspectiveCamera();
        this.translate = new Translate(0, -5000, -2200);
        this.rotateX = new Rotate(-60, Rotate.X_AXIS);
        this.rotateY = new Rotate(0, Rotate.Y_AXIS);
        this.camera.getTransforms().addAll(translate, rotateX, rotateY);
    }

    public void initializeRotationControls(Group group, Scene scene) {
        Rotate rotateX = new Rotate(0, Rotate.X_AXIS);
        Rotate rotateY = new Rotate(0, Rotate.Y_AXIS);
        Rotate rotateZ = new Rotate(0, Rotate.Z_AXIS);

        group.getTransforms().addAll(rotateX, rotateY, rotateZ);

        scene.setOnKeyPressed(event -> {
            switch (event.getCode()) {
                case X -> zoom(-200);   // Zoom in
                case Z -> zoom(200);    // Zoom out

                case UP -> rotateX.setAngle(rotateX.getAngle() + 25); // Rotation by X
                case DOWN -> rotateX.setAngle(rotateX.getAngle() - 25); // Rotation by X
                case LEFT -> rotateY.setAngle(rotateY.getAngle() - 25); // Rotation by Y
                case RIGHT -> rotateY.setAngle(rotateY.getAngle() + 25); // Rotation by Y

                case C -> getView(-45.0, 0.0, 0.0, -5000.0, -4200.0); // Scene 1
                case V -> getView(-60.0, 0.0, 0.0, -5000.0, -2200); // Scene 2
            }
        });
    }

    private void getView(double rotationX, double rotationY, double translationX, double translationY, double translationZ) {
        rotateX.setAngle(rotationX);
        rotateY.setAngle(rotationY);
        translate.setX(translationX);
        translate.setY(translationY);
        translate.setZ(translationZ);
    }

    private void zoom(double deltaZ) {
        translate.setZ(translate.getZ() + deltaZ);
    }
}

====================
FILE: SceneRenderer.java

package com.jakub.bone.ui.utills;

import com.jakub.bone.ui.model.TerminalModel;
import com.jakub.bone.application.ControlTower;
import com.jakub.bone.domain.airport.Airport;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import com.jakub.bone.ui.model.AirspaceModel;
import com.jakub.bone.ui.model.RunwayModel;

public class SceneRenderer extends Application {
    private SmartGroup group;
    private Scene scene;
    private Camera camera;
    private Airport airport;
    private final ControlTower controller;

    public SceneRenderer(ControlTower controller) {
        this.group = new SmartGroup(0.5, 0.5, 0.5);
        this.scene = new Scene(group, 800, 600, Color.BLACK);
        this.camera = new Camera();
        this.airport = new Airport();
        this.controller = controller;
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        scene.setCamera(camera.getCamera());

        SceneUpdater updater = new SceneUpdater(group, controller);

        setupStaticElements();
        setupRotationHandler();

        updater.start();

        primaryStage.setTitle("Airport Automatic Landing System");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    private void setupStaticElements(){
        RunwayModel runway1Model = new RunwayModel(Airport.runway1);
        RunwayModel runway2Model = new RunwayModel(Airport.runway2);
        AirspaceModel airspaceModel = new AirspaceModel();
        TerminalModel terminal1Model = new TerminalModel(-1000, 50, 2000);
        TerminalModel terminal2Model = new TerminalModel(1000, 50, 2000);

        group.getChildren().addAll(airspaceModel.getFloor(), airspaceModel.getLeftWall(), airspaceModel.getRightWall(),
                runway1Model.getRunwayRect(), runway2Model.getRunwayRect(), terminal1Model.getPlaneGroup(), terminal2Model.getPlaneGroup());
    }

    private void setupRotationHandler(){
        camera.initializeRotationControls(group, scene);
    }

    public static void main (String[]args){
        launch(args);
    }

}

====================
FILE: SceneUpdater.java

package com.jakub.bone.ui.utills;

import com.jakub.bone.ui.model.PlaneModel;
import com.jakub.bone.application.ControlTower;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.scene.Group;
import javafx.scene.paint.Color;
import javafx.util.Duration;

import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.domain.plane.Plane;

import java.util.*;

import static com.jakub.bone.domain.plane.Plane.FlightPhase.LANDING;

public class SceneUpdater {
    private final Group root;
    private ControlTower controller;
    private Map<String, PlaneModel> planesMap;
    private boolean isFirstPlane;

    public SceneUpdater(Group root, ControlTower controller) {
        this.root = root;
        this.controller = controller;
        this.planesMap = new HashMap<>();
        this.isFirstPlane = true;
    }

    public void start() {
        Timeline timeline = new Timeline(new KeyFrame(Duration.millis(1000), event -> updateAirspace()));
        timeline.setCycleCount(Timeline.INDEFINITE);
        timeline.play();
    }

    private void updateAirspace() {
        List<Plane> planes = controller.getPlanes();

        for (Plane plane : planes) {
            if(isFirstPlane){
                try{
                    Thread.sleep(500);
                } catch (InterruptedException ex){
                    ex.getMessage();
                }
                isFirstPlane = false;
            }
            PlaneModel planeModel;
            if (!planesMap.containsKey(plane.getFlightNumber())) {
                planeModel = new PlaneModel(plane);
                planesMap.put(plane.getFlightNumber(), planeModel);
                root.getChildren().addAll(planeModel.getPlaneGroup(), planeModel.getLabel());
            }

            planeModel = planesMap.get(plane.getFlightNumber());
            if(plane.getPhase().equals(LANDING)){
                planeModel.setPlaneModelColor(Color.YELLOW);
            }

            Location nextWaypoint = plane.getNavigator().getLocation();
            planeModel.animateMovement(nextWaypoint);
        }
        cleanupScene();
    }

    private void cleanupScene(){
        for (String flightNumber : planesMap.keySet()) {
            Plane plane = controller.getPlaneByFlightNumber(flightNumber);
            PlaneModel planeModel = planesMap.get(flightNumber);
            if (plane == null || plane.isDestroyed() || plane.isLanded()) {
                root.getChildren().removeAll(planeModel.getPlaneGroup(), planeModel.getLabel());
            }
        }
    }
}


====================
FILE: SmartGroup.java

package com.jakub.bone.ui.utills;

import javafx.scene.Group;

import javafx.scene.transform.Scale;

public class SmartGroup extends Group {

    public SmartGroup(double v, double v1, double v2) {
        this.getTransforms().add(new Scale(v, v1, v2));
    }
}

====================
FILE: Constant.java

package com.jakub.bone.utills;

import com.jakub.bone.domain.airport.Location;

public class Constant {
    // Runway dimensions
    public static final int RUNWAY_WIDTH = 5000; // in meters
    public static final int RUNWAY_HEIGHT = 1000; // in meters

    // Airplane limitations
    public static final int MAX_CAPACITY = 100; // max number of airplanes in airspace
    public static final int MAX_ALTITUDE = 5000; // in meters
    public static final int MIN_ALTITUDE = 2000; // in meters
    public static final double ALTITUDE_COLLISION_DISTANCE = 10.0; // in meters
    public static final double HORIZONTAL_COLLISION_DISTANCE = 500.0; // in meters

    // Fuel-related values
    public static final double CONSUMPTION_PER_HOUR = 2000; // in liters
    public static final double INITIAL_FUEL_LEVEL = 6000; // for 3 hours in liters
    public static final double CONSUMPTION_PER_SECOND = CONSUMPTION_PER_HOUR / 3600.0; // in liters

    // Time-related values
    public static final long COLLISION_CHECK_INTERVAL = 1000; // in milliseconds

    // Landing-related values
    public static int LANDING_ALTITUDE = 700; // in meters
    public  static Location LANDING_POINT_RUNWAY_1 = new Location(3000, 1500, 0);
    public static Location LANDING_POINT_RUNWAY_2 = new Location(3000, -1500, 0);
    public static Location ENTRY_POINT_CORRIDOR_1 = new Location(-5000, 3500, 1000);
    public static Location ENTRY_POINT_CORRIDOR_2 = new Location(-5000, 500, 1000);
    public static Location FINAL_APPROACH_CORRIDOR_1 = new Location(-2000, 1500, 500);
    public static Location FINAL_APPROACH_CORRIDOR_2 = new Location(-2000, -1500, 500);


    // Holding-related
    public static int HOLDING_ALTITUDE = 1000; // in meters
    public static int HOLDING_ENTRY_ALTITUDE = 1013; // in meters
}

====================
FILE: Messenger.java

package com.jakub.bone.utills;

import com.google.gson.Gson;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Messenger {
    private Gson gson;
    public Messenger() {
        this.gson = new Gson();
    }

    public void send(Object message, ObjectOutputStream out) throws IOException {
        if (message instanceof Integer) {
            // Send the enum as a plain string
            out.writeObject(((Integer) message).toString());
        } else {
            // Serialize other objects as JSON
            String jsonMessage = gson.toJson(message);
            out.writeObject(jsonMessage);
        }
        out.flush();

    }

    public <T> T receiveAndParse(ObjectInputStream in, Class<T> type) throws IOException, ClassNotFoundException {
        String json = (String) in.readObject();
        return gson.fromJson(json, type);
    }
}

====================
FILE: WaypointGenerator.java

package com.jakub.bone.utills;

import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.domain.airport.Runway;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import static com.jakub.bone.utills.Constant.*;

public class WaypointGenerator implements Serializable {
    public static List<Location> getDescentWaypoints() {
        List<Location> waypoints = new ArrayList<>();
        int radius = 5000;
        int totalWaypoints = 320;
        double altitudeDecrease = (double) (MAX_ALTITUDE - HOLDING_ALTITUDE) / totalWaypoints;

        // Each 80 points for one lap of circle
        double angleStep = 360.0 / 80;

        double currentAltitude = MAX_ALTITUDE;

        for (int i = 0; i < totalWaypoints; i++) {
            // Convert the angle to radians for math calculations
            // (i % 80) angle resets after every 80 waypoints, completing a full circle (360 degrees)
            // angleStep defines the angular interval between next points
            double radians = Math.toRadians((i % 80) * angleStep);

            // Calculate coordinates based on circular geometry
            int x = (int) (radius * Math.cos(radians));
            int y = (int) (radius * Math.sin(radians));

            waypoints.add(new Location(x, y, (int) Math.round(currentAltitude)));

            currentAltitude -= altitudeDecrease;
        }
        return waypoints;
    }

    public static List<Location> getHoldingPatternWaypoints() {
        List<Location> waypoints = new ArrayList<>();
        int step = 500; // Distance between waypoints in holding pattern way

        // Line going upwards along the y-axis
        for (int y = 0; y <= 3000; y += step) {
            waypoints.add(new Location(5000, y, HOLDING_ALTITUDE));
        }
        // Curve for the top-right corner
        waypoints.addAll(generateArc(3500, 3500, 1500, 0, 90, HOLDING_ALTITUDE, 0));

        // Line going left along the x-axis
        for (int x = 3000; x >= -3000; x -= step) {
            waypoints.add(new Location(x, 5000, HOLDING_ALTITUDE));
        }
        // Curve for the top-left corner
        waypoints.addAll(generateArc(-3500, 3500, 1500, 90, 180, HOLDING_ALTITUDE, 0));

        // Line going downward along the y-axis
        for (int y = 3000; y >= -3000; y -= step) {
            waypoints.add(new Location(-5000, y, HOLDING_ALTITUDE));
        }
        // Curve for the bottom-left corner
        waypoints.addAll(generateArc(-3500, -3500, 1500, 180, 270, HOLDING_ALTITUDE, 0));

        // Line going right along the x-axis
        for (int x = -3000; x <= 3000; x += step) {
            waypoints.add(new Location(x, -5000, HOLDING_ALTITUDE));
        }
        // Curve for the bottom-right corner
        waypoints.addAll(generateArc(3500, -3500, 1500, -90, 0, HOLDING_ALTITUDE, 0));

        // Line to connect rest of way to the start
        for (int y = -3000; y <= -500; y += step) {
            waypoints.add(new Location(5000, y, HOLDING_ALTITUDE));
        }
        return waypoints;
    }

    public static List<Location> generateArc(int centerX, int centerY, int radius, double startAngle, double endAngle, int altitude, int altitudeDecrement) {
        List<Location> arcPoints = new ArrayList<>();
        int waypointsOnArc = 4;
        double angleStep = (endAngle - startAngle) / (waypointsOnArc - 1);

        for (int i = 0; i < waypointsOnArc; i++) {
            // Calculate the angle in radians for the current waypoint
            // startAngle is the initial angle of the arc, and angleStep defines the angular increment between points
            double angle = Math.toRadians(startAngle + i * angleStep);
            // Compute the X and Y coordinate using the formula for a point's position on a circle
            // centerX is the circle's center along the X-axis
            // centerY is the circle's center along the Y-axis
            int x = (int) (centerX + radius * Math.cos(angle));
            int y = (int) (centerY + radius * Math.sin(angle));
            arcPoints.add(new Location(x, y, altitude));
            altitude -= altitudeDecrement;
        }
        return arcPoints;
    }

    public static List<Location> getLandingWaypoints(Runway runway) {
        List<Location> waypoints = new ArrayList<>();
        int landingWaypoints = 10;
        int altitude = HOLDING_ALTITUDE;
        int altitudeDecrement = altitude / landingWaypoints;

        int arcCenterY = "R-2".equals(runway.getId()) ? 0 : 3000;

        // Generate the arc that leads planes into the runway's corridor
        List<Location> arc4 = generateArc(-3500, arcCenterY, 1500, 180, 270, altitude, altitudeDecrement);
        for(Location waypoint: arc4){
            waypoints.add(waypoint);
        }

        // Start lowering altitude toward the ground level
        // Calculate the position for the waypoints leading to the runway
        altitude = LANDING_ALTITUDE;
        int landingDescentY = runway.getCorridor().getEntryPoint().getY() - 2000;
        for (int x = -3000; x <= 500; x += 500) {
            waypoints.add(new Location(x, landingDescentY, altitude));
            altitude -= altitudeDecrement;
        }

        // Add waypoints directly on the runway stop point
        altitude = 0;
        for (int x = 1000; x <= 3000; x += 250) {
            waypoints.add(new Location(x, runway.getLandingPoint().getY(), altitude));
        }
        return waypoints;
    }
}


====================
FILE: ClientServerConnectionTest.java

package integration_tests;

import com.jakub.bone.client.PlaneClient;
import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;
import org.junit.jupiter.api.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;
import com.jakub.bone.server.AirportServer;

import java.io.IOException;
import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

class ClientServerConnectionTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository planeRepository;
    @Mock
    CollisionRepository collisionRepository;
    ControlTower controlTower;
    AirportServer server;

    @BeforeEach
    void setUp() throws IOException, SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(planeRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(collisionRepository);

        this.controlTower = new ControlTower(mockDatabase);
            new Thread(() -> {
                try {
                    this.server = new AirportServer(controlTower);
                    this.server.startServer(5000);
                } catch (IOException | SQLException ex) {
                    throw new RuntimeException(ex);
                }
            }).start();
    }
    @AfterEach
    void tearDown() throws IOException {
        if (server != null) {
            server.stopServer();
        }
    }

    /**
     * Helper method to wait for the server to start without repeating try-catch blocks
     */
    private void waitForStart() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }

    @Test
    @DisplayName("Should test single client connection")
    void testSingleClientConnection() {
        // Wait for the server to start
        waitForStart();

        PlaneClient planeClient = new PlaneClient("localhost", 5000);
        new Thread(planeClient).start();

        // Give some time for the client to connect
        waitForStart();

        assertTrue(planeClient.isConnected(), "Client should successfully connect to the server");
    }

    @Test
    @DisplayName("Should test multiple clients connection")
    void testConnectionWithMultipleClients() {
        waitForStart();

        PlaneClient planeClient1 = new PlaneClient("localhost", 5000);
        new Thread(planeClient1).start();

        // Wait for the first client to connect
        waitForStart();

        PlaneClient planeClient2 = new PlaneClient("localhost", 5000);
        new Thread(planeClient2).start();

        // Wait for the second client to connect
        waitForStart();

        assertTrue(planeClient1.isConnected(), "Client1 should successfully connect to the server");
        assertTrue(planeClient2.isConnected(), "Client2 should successfully connect to the server");
    }

    @Test
    @DisplayName("Should test client registration")
    void testClientRegistration() {
        try{
            Thread.sleep(2000);
        } catch (InterruptedException ex){
            ex.printStackTrace();
        }
        PlaneClient planeClient = new PlaneClient("localhost", 5000);
        new Thread(planeClient).start();
            try{
                Thread.sleep(2000);
            } catch (InterruptedException ex){
                ex.printStackTrace();
            }
        assertEquals(1, server.getControlTower().getPlanes().size(),
                "Planes list should contain only one Plane object after registration");
    }

    @Test
    @DisplayName("Should test client registration with full capacity")
    void testClientRegistrationWithFullCapacity() {
        waitForStart();

        // Fill the list with 100 planes
        for(int i = 0; i < 100; i++){
            Plane plane = new Plane("TEST_PLANE");
            server.getControlTower().getPlanes().add(plane);
        }

        PlaneClient planeClient = new PlaneClient("localhost", 5000);
        new Thread(planeClient).start();

        // Wait for the client to attempt registration
        waitForStart();

        assertEquals(100, server.getControlTower().getPlanes().size(),
                "Plane list should contain only 100 planes; the new plane should not be added");
    }
}

====================
FILE: ClientTest.java

package load_tests;

import com.jakub.bone.client.PlaneClient;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * Continuously spawns PlaneClient instances every 5 seconds,
 * simulating a sustained load for performance testing
 */
public class ClientTest {
    static final Logger logger = Logger.getLogger(ClientTest.class.getName());

    public static void main(String[] args) {
        // Automatically stop after 60 minutes
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                logger.info("Client stopped after 60 minutes");
                System.exit(0);
            }
        }, 3600000);

        ExecutorService executorService = Executors.newCachedThreadPool();

        while (true) {
            try {
                PlaneClient client = new PlaneClient("localhost", 5000);
                executorService.execute(client);

                try {
                    Thread.sleep(5000);
                } catch (InterruptedException ex) {
                    logger.log(Level.WARNING, "Client thread interrupted", ex);
                    Thread.currentThread().interrupt();
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, "An error occurred", e);
            }
        }
    }
}


====================
FILE: ServerTest.java

package load_tests;

import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.server.AirportServer;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * This class tests the behavior of the server under high load conditions
 */
public class ServerTest {
    static final Logger logger = Logger.getLogger(ClientTest.class.getName());
    public static void main(String[] args) throws IOException, SQLException {
        AirportDatabase airportDatabase = new AirportDatabase();
        ControlTower controller = new ControlTower(airportDatabase);

        AirportServer airportServer = null;
        try {
            airportServer = new AirportServer(controller);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        airportServer = new AirportServer(controller);

        // Automatically stop after 70 minutes
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                logger.info("Server stopped after 70 minutes");
                System.exit(0);

            }
        }, 4200000);

        try {
            airportServer.startServer(5000);
        } catch (Exception ex) {
            logger.log(Level.WARNING, "Failed to start the server:", ex.getMessage());
        }
    }
}

====================
FILE: CollisionTest.java

package unit_tests.airspace;

import com.jakub.bone.application.CollisionDetector;
import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;
import com.jakub.bone.domain.airport.Location;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;

import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.assertFalse;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

class CollisionTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository mockPlaneRepository;
    @Mock
    CollisionRepository mockCollisionRepository;
    ControlTower controlTower;
    CollisionDetector collisionDetector;

    @BeforeEach
    void setUp() throws SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(mockPlaneRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(mockCollisionRepository);
        this.controlTower = new ControlTower(mockDatabase);
        this.collisionDetector = new CollisionDetector(controlTower);
    }

    //Helper method to create a plane, set its location, and register
    Plane createAndRegisterPlane(String name, int x, int y, int altitude) {
        Plane plane = new Plane(name);
        plane.getNavigator().setLocation(new Location(x, y, altitude));
        controlTower.registerPlane(plane);
        return plane;
    }

    @Test
    @DisplayName("Should test collision if distance between planes is less than 10 meters")
    void tesPlanesCollisionAtTheSameLocalisation(){
        // Create two planes whose distance is under 10 meters
        Plane plane1 = createAndRegisterPlane("TEST_PLANE_1", 5000, 5000, 4010);
        Plane plane2 = createAndRegisterPlane("TEST_PLANE_2", 5000, 5000, 4000);

        collisionDetector.checkCollision();

        // Both planes should be destroyed
        assertTrue(plane1.isDestroyed(), "TEST_PLANE_1 should be destroyed after collision");
        assertTrue(plane2.isDestroyed(), "TEST_PLANE_2 should be destroyed after collision");
    }

    @Test
    @DisplayName("Should test collision registration if distance between planes equal 10 meters")
    void tesPlanesCollisionAtRiskZone(){
        // Create two planes whose distance is exactly 10 meters
        Plane plane1 = createAndRegisterPlane("TEST_PLANE_1", 5000, 5000, 4010);
        Plane plane2 = createAndRegisterPlane("TEST_PLANE_2", 5000, 5000, 4000);

        collisionDetector.checkCollision();

        // Both planes should be destroyed
        assertTrue(plane1.isDestroyed(), "TEST_PLANE_1 should be destroyed after collision");
        assertTrue(plane2.isDestroyed(), "TEST_PLANE_2 should be destroyed after collision");
    }

    @Test
    @DisplayName("Should test registration collision avoiding if planes beyond risk zone")
    void testPlanesCollisionBeyondRiskZone(){
        // Create two planes whose distance is more than 10 meters
        Plane plane1 = createAndRegisterPlane("TEST_PLANE_1", 5000, 5000, 4020);
        Plane plane2 = createAndRegisterPlane("TEST_PLANE_2", 5000, 5000, 4000);

        collisionDetector.checkCollision();

        // Both planes should remain intact
        assertFalse(plane1.isDestroyed(), "TEST_PLANE_1 should not be destroyed after collision");
        assertFalse(plane2.isDestroyed(), "TEST_PLANE_2 should not be destroyed after collision");
    }
}

====================
FILE: ControlTowerTest.java

package unit_tests.airspace;

import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

class ControlTowerTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository mockPlaneRepository;
    @Mock
    CollisionRepository mockCollisionRepository;
    ControlTower controlTower;
    List<Plane> incomingPlanes;
    @BeforeEach
    void setUp() throws SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(mockPlaneRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(mockCollisionRepository);
        controlTower = new ControlTower(mockDatabase);
        incomingPlanes = new ArrayList<>();
    }

    @Test
    @DisplayName("Should register all incoming planes correctly")
    void testRegisterPlane(){
        // Prepare a list of 10 planes
        for (int i = 0; i < 10; i++){
            incomingPlanes.add(new Plane("TEST_PLANE"));
        }

        // Register each plane
        for(Plane incoming: incomingPlanes){
            controlTower.registerPlane(incoming);
        }

        // Assert that all were registered
        assertEquals(10, controlTower.getPlanes().size(),
                "Plane list should contain exactly 10 planes");
        assertTrue(controlTower.getPlanes().size() == 10,
                "All incoming planes should be registered");
    }

    @Test
    @DisplayName("Should detect when airspace reaches maximum capacity")
        void testIsSpaceFull(){
        // Prepare a list of 110 planes
        for (int i = 0; i < 110; i++) {
            incomingPlanes.add(new Plane("TEST_PLANE"));
        }

        // Register each plane
        for (Plane plane : incomingPlanes) {
            controlTower.registerPlane(plane);
        }

        assertTrue(controlTower.isSpaceFull(),
                "Control tower should report that maximum capacity is reached");
    }

    @Test
    @DisplayName("Should detect when an incoming plane is within the collision risk zone")
    void testIfPlaneAtCollisionRiskZone() {
        // Register the first plane
        Plane plane1 = new Plane("TEST_PLANE_1");
        controlTower.registerPlane(plane1);

        // Retrieve its current index and shift the second plane's index by +1
        int referenceIndex = plane1.getNavigator().getCurrentIndex();

        Plane plane2 = new Plane("TEST_PLANE_2");
        plane2.getNavigator().setCurrentIndex(referenceIndex + 1);

        assertTrue(controlTower.isAtCollisionRiskZone(plane2),
                "Plane2 should be recognized as within collision risk zone relative to Plane1");
    }

    @Test
    @DisplayName("Should remove plane from airspace correctly")
    void testRemovePlaneFromSpace(){
        // Register plane
        Plane plane = new Plane("TEST_PLANE");
        controlTower.registerPlane(plane);

        // Remove plane
        controlTower.removePlaneFromSpace(plane);

        assertFalse(controlTower.getPlanes().contains(plane),
                "TEST_PLANE should be removed from airspace");
    }
}

====================
FILE: RunwayTest.java

package unit_tests.airspace;

import com.jakub.bone.domain.airport.Airport;

import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;

import java.sql.SQLException;

import static com.jakub.bone.domain.airport.Airport.runway1;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;
import static com.jakub.bone.utills.Constant.FINAL_APPROACH_CORRIDOR_1;

class RunwayTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository mockPlaneRepository;
    @Mock
    CollisionRepository mockCollisionRepository;
    ControlTower controlTower;
    Airport airport;

    @BeforeEach
    void setUp() throws SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(mockPlaneRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(mockCollisionRepository);
        controlTower = new ControlTower(mockDatabase);
        airport = new Airport();
    }

    @Test
    @DisplayName("Runway should initially be available")
    void testIsRunwayAvailableInitially(){
        // By default, the runway is assumed available
        assertTrue(controlTower.isRunwayAvailable(runway1),
                "Runway should be set as available at the beginning");
    }

    @Test
    @DisplayName("Runway can be set to unavailable")
    void testSetRunwayAsUnavailable(){
        runway1.setAvailable(false);
        assertFalse(controlTower.isRunwayAvailable(runway1),
                "Runway should be set as unavailable" );
    }

    @Test
    @DisplayName("Assigning a runway makes it unavailable")
    void testAssignRunwayMakesItOccupied(){
        // Once assigned, the runway is not available anymore
        controlTower.assignRunway(runway1);

        assertFalse(runway1.isAvailable(),
                "Runway should be unavailable (occupied) after assignment");
    }

    @Test
    @DisplayName("Releasing a runway makes it available again")
    void testReleaseRunway(){
        // Once released, the runway is available
        controlTower.releaseRunway(runway1);

        assertTrue(runway1.isAvailable(), "Runway should be available after being released");
    }

    @Test
    @DisplayName("Runway is released when a plane crosses final approach point")
    void testReleaseRunwayIfPlaneIsAtFinalAtApproach(){
        Plane plane = new Plane("TEST_PLANE");
        plane.getNavigator().setLocation(FINAL_APPROACH_CORRIDOR_1);

        controlTower.releaseRunwayIfPlaneAtFinalApproach(plane, runway1);

        assertTrue(runway1.isAvailable(),
                "Runway should be released after the plane reaches the final approach point");
    }
}

====================
FILE: DatabaseConnectionTest.java

package unit_tests.database;

import com.jakub.bone.database.AirportDatabase;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

class DatabaseConnectionTest {
    AirportDatabase database;

    @BeforeEach
    void setUp() throws SQLException {
        this.database = new AirportDatabase();
    }

    @Test
    @DisplayName("Database connection should not return be null")
    void testGetConnection() throws SQLException {
        assertNotNull(database.getDatabaseConnection(), "Database connection should not return null");
    }

    @Test
    @DisplayName("Database connection should close properly")
    void testCloseConnection() throws SQLException {
        database.closeConnection();
        assertTrue(database.getConnection().isClosed(), "Database connection should be closed");
    }
}

====================
FILE: DatabaseOperationTest.java

package unit_tests.database;

import com.jakub.bone.application.CollisionDetector;
import com.jakub.bone.domain.airport.Airport;
import com.jakub.bone.application.ControlTower;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;

import java.sql.SQLException;

import static com.jakub.bone.domain.airport.Airport.runway1;
import static org.mockito.Mockito.*;
import static com.jakub.bone.utills.Constant.ENTRY_POINT_CORRIDOR_1;

class DatabaseOperationTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository mockPlaneRepository;
    @Mock
    CollisionRepository mockCollisionRepository;
    ControlTower controlTower;
    CollisionDetector collisionDetector;

    @BeforeEach
    void setUp() throws SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(mockPlaneRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(mockCollisionRepository);
        controlTower = new ControlTower(mockDatabase);
        collisionDetector = new CollisionDetector(controlTower);
    }

    @Test
    @DisplayName("Plane registration should be saved to the database")
    void testPlaneRegisterToDatabase() throws SQLException {
        Plane plane = new Plane("TEST_PLANE");

        // Registration should trigger a DB operation
        controlTower.registerPlane(plane);

        verify(mockPlaneRepository, times(1)).registerPlaneInDB(plane);
    }

    @Test
    @DisplayName("Landing should be saved to the database")
    void testLandingRegisterToDatabase() throws SQLException {
        Airport airport = new Airport();
        Plane plane = new Plane("TEST_PLANE");

        // Place the plane on the runway's landing point
        plane.getNavigator().setLocation(runway1.getLandingPoint());
        // Inform control tower that plane has landed
        controlTower.hasLandedOnRunway(plane, runway1);

        verify(mockPlaneRepository, times(1)).registerLandingInDB(plane);
    }

    @Test
    @DisplayName("Collision should be saved to the database")
    void testCollisionRegisterToDatabase() throws SQLException {
        Plane plane1 = new Plane("TEST_PLANE_1");
        Plane plane2 = new Plane("TEST_PLANE_2");

        // Both planes share the same location => collision scenario
        plane1.getNavigator().setLocation(ENTRY_POINT_CORRIDOR_1);
        plane2.getNavigator().setLocation(ENTRY_POINT_CORRIDOR_1);

        controlTower.getPlanes().add(plane1);
        controlTower.getPlanes().add(plane2);

        collisionDetector.checkCollision();

        // Build the IDs array that the control tower will pass to the DAO
        String[] collidedIDs = {plane1.getFlightNumber(), plane2.getFlightNumber()};

        verify(mockCollisionRepository, times(1)).registerCollisionToDB(collidedIDs);
    }
}

====================
FILE: FlightPhaseTest.java

package unit_tests.flight;

import com.jakub.bone.domain.airport.Airport;

import com.jakub.bone.application.ControlTower;
import com.jakub.bone.application.FlightPhaseCoordinator;
import com.jakub.bone.database.AirportDatabase;
import com.jakub.bone.database.CollisionRepository;
import com.jakub.bone.database.PlaneRepository;
import com.jakub.bone.domain.airport.Location;
import com.jakub.bone.utills.WaypointGenerator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.jakub.bone.domain.plane.Plane;
import com.jakub.bone.utills.Messenger;

import java.io.IOException;
import java.sql.SQLException;

import static com.jakub.bone.domain.airport.Airport.runway1;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static com.jakub.bone.domain.plane.Plane.FlightPhase.*;
import static com.jakub.bone.utills.Constant.FINAL_APPROACH_CORRIDOR_1;

/*
 * This class tests how a plane's flight phase changes
 * based on its location and interactions with the ControlTower
 */
class FlightPhaseTest {
    @Mock
    AirportDatabase mockDatabase;
    @Mock
    PlaneRepository mockPlaneRepository;
    @Mock
    CollisionRepository mockCollisionRepository;
    ControlTower controlTower;
    FlightPhaseCoordinator phaseCoordinator;
    Airport airport;
    Messenger messenger;

    @BeforeEach
    void setUp() throws SQLException {
        MockitoAnnotations.openMocks(this);
        when(mockDatabase.getPLANE_DAO()).thenReturn(mockPlaneRepository);
        when(mockDatabase.getCOLLISION_DAO()).thenReturn(mockCollisionRepository);
        this.controlTower = new ControlTower(mockDatabase);
        this.airport = new Airport();
        this.messenger = mock(Messenger.class);
        this.phaseCoordinator = new FlightPhaseCoordinator(controlTower, airport, messenger);

    }

    @Test
    @DisplayName("Should test flight phase set as DESCENDING after plane spawn")
    void testPhaseSettingToDescending() throws IOException, ClassNotFoundException {
        // Plane spawns at a certain altitude
        Plane plane = new Plane("TEST_PLANE");
        Location descentPoint = new Location(0, 0, 3000);

        phaseCoordinator.processFlightPhase(plane, descentPoint, null);

        assertEquals(DESCENDING, plane.getPhase(), "Flight phase should be set as DESCENDING");
    }

    @Test
    @DisplayName("Should test flight phase switch to holding")
    void testPhaseSwitchToHolding() throws IOException, ClassNotFoundException {
        // Plane has reached the end of its descent waypoints
        Plane plane = new Plane("TEST_PLANE");
        plane.getNavigator().setCurrentIndex(WaypointGenerator.getDescentWaypoints().size());
        plane.descend();

        // Holding altitude = 1000
        Location holdingPoint = new Location(0, 0, 1000);
        phaseCoordinator.processFlightPhase(plane, holdingPoint, null);

        assertEquals(HOLDING, plane.getPhase(), "Flight phase should be switched to HOLDING");
    }

    @Test
    @DisplayName("Should test flight phase switch to LANDING when plane is at corridor entry point")
    void testPhaseSwitchToLandingAtCorridorEntryPoint() throws IOException, ClassNotFoundException {
        // Plane is currently in the holding pattern
        Plane plane = new Plane("TEST_PLANE");
        plane.getNavigator().setWaypoints(WaypointGenerator.getHoldingPatternWaypoints());
        plane.setPhase(HOLDING);

        // Corridor entry triggers the switch to LANDING
        Location corridorEntry = runway1.getCorridor().getEntryPoint();
        phaseCoordinator.processFlightPhase(plane, corridorEntry, null);

        assertEquals(LANDING, plane.getPhase(), "Flight phase should be switched to LANDING");
    }

    @Test
    @DisplayName("Should test correct plane marking as landed after landing process")
    void testMarkingAsLanded(){
        // Plane is at the runway landing point
        Plane plane = new Plane("TEST_PLANE");
        plane.getNavigator().setLocation(runway1.getLandingPoint());

        assertTrue(controlTower.hasLandedOnRunway(plane, runway1), "TEST_PLANE should be marked as landed");
    }

    @Test
    @DisplayName("Should test runway release after crossing final approach point")
    void testRunwayReleaseAfterCrossFinalApproach() {
        // Plane is exactly at final approach coordinates
        Plane plane = new Plane("TEST_PLANE");
        plane.getNavigator().setLocation(FINAL_APPROACH_CORRIDOR_1);

        // Initially mark runway as unavailable
        runway1.setAvailable(false);

        // The plane crossing final approach triggers runway release
        controlTower.releaseRunwayIfPlaneAtFinalApproach(plane, runway1);

        assertTrue(runway1.isAvailable(), "Runway should be set as available");
    }
}

====================
FILE: FuelManagerTest.java

package unit_tests.flight;

import com.jakub.bone.utills.Constant;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import com.jakub.bone.domain.plane.Plane;

import static org.junit.jupiter.api.Assertions.assertEquals;

class FuelManagerTest {
    @Test
    @DisplayName("Fuel level should decrease by the consumption rate after burnFuel() call")
    void testBurnFuel() {
        Plane plane = new Plane("TEST_PLANE");

        // Capture the plane's current consumption rate
        double consumption = Constant.CONSUMPTION_PER_SECOND;

        // Record initial fuel level
        double initialFuelLevel = plane.getFuelManager().getFuelLevel();

        // Trigger fuel burn
        plane.getFuelManager().burnFuel();

        // Verify the fuel level decreased by exactly the consumption rate
        double currentFuelLevel = plane.getFuelManager().getFuelLevel();

        assertEquals(currentFuelLevel, initialFuelLevel - consumption, "TEST_PLANE fuel level should be reduced");
    }
}

====================
FILE: LocationTest.java

package unit_tests.flight;

import com.jakub.bone.domain.airport.Location;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import com.jakub.bone.domain.plane.Plane;

import static org.junit.jupiter.api.Assertions.*;

class LocationTest {
    @Test
    @DisplayName("Plane should update its location correctly")
    void testUpdateLocation() {
        Plane plane = new Plane("TEST_PLANE");
        Location initLocation = new Location(1000, 1000, 1000);
        Location newLocation = new Location(5000, 5000, 5000);

        // Assign initial location
        plane.getNavigator().setLocation(initLocation);

        // Update location
        plane.getNavigator().updateLocation(newLocation, plane.getFlightNumber());

        assertNotEquals(plane.getNavigator().getLocation(), initLocation, "Plane should not remain at the initial location");
        assertEquals(plane.getNavigator().getLocation(), newLocation, "Plane should have the new location after update");
    }

    @Test
    @DisplayName("Location equals() should distinguish different coordinates")
    void testEqualLocationIdentification(){
        // Two planes with different locations
        Plane plane1 = new Plane("TEST_PLANE_1");
        plane1.getNavigator().setLocation(new Location(1000, 1000, 1000));

        Plane plane2 = new Plane("TEST_PLANE_2");
        plane1.getNavigator().setLocation(new Location(5000, 5000, 5000));
        // Compare the locations
        boolean isLocationEqual = plane1.getNavigator()
                                        .getLocation()
                                        .equals(plane2.getNavigator().getLocation());

        assertFalse(isLocationEqual, "Locations with different coordinates should not be equal");
    }
}

